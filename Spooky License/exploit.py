# file spookylicence. 
# Esto nos dice que el binario es un Position Independent Executable. Esto hace que se pueda cargar a cualquier parte de memoria, algo que ayuda para el Address Space Layout Randomization.
#
import angr # Ejecucion simbolica
import claripy # Provides symbolic values and constraint-solving capabilities

p = angr.Project("spookylicence", auto_load_libs=False)

argv = [p.filename] # Se a√±ade el nombre del archivo en los argumentos por convencion
sym_arg_size = 
sym_arg = claripy.BVS('sym_arg', 8*sym_arg_size)
argv.append(sym_arg)
# Options
# ZERO_FILL_UNCONSTRAINED_REGISTERS: Se asegura que los registros no inicializados se llenen con 0. Se hace porque un registro que no tiene un valor definido puede introducir symbolic values, lo cual puede agregar complejidad innecsaria.
# ZERO_FILL_UNCONSTRAINED_MEMORY: Las memorias que no han sido escritas se llenan con 0 para evitar agregar esa complejidad.
state = p.factory.entry_state(args=argv, add_options={angr.sim_options.ZERO_FILL_UNCONSTRAINED_REGISTERS, angr.sim_options.ZERO_FILL_UNCONSTRAINED_MEMORY})

sm = p.factory.simulation_manager(state)  # Create simulation manager

if sm.found:
    solution = sm.found[0].solver.eval(argv[1], cast_to=bytes)
    print(solution)