# file spookylicence. 
# Esto nos dice que el binario es un Position Independent Executable. Esto hace que se pueda cargar a cualquier parte de memoria, algo que ayuda para el Address Space Layout Randomization.
#
import angr # Ejecucion simbolica
import claripy # Provides symbolic values and constraint-solving capabilities

p = angr.Project("spookylicence", auto_load_libs=False)

argv = [p.filename] # Se a√±ade el nombre del archivo en los argumentos por convencion
sym_arg_size = 32
sym_arg = claripy.BVS('sym_arg', 8*sym_arg_size)
argv.append(sym_arg)
# Options
# ZERO_FILL_UNCONSTRAINED_REGISTERS: Se asegura que los registros no inicializados se llenen con 0. Se hace porque un registro que no tiene un valor definido puede introducir symbolic values, lo cual puede agregar complejidad innecsaria.
# ZERO_FILL_UNCONSTRAINED_MEMORY: Las memorias que no han sido escritas se llenan con 0 para evitar agregar esa complejidad.
state = p.factory.entry_state(args=argv, add_options={angr.sim_options.ZERO_FILL_UNCONSTRAINED_REGISTERS, angr.sim_options.ZERO_FILL_UNCONSTRAINED_MEMORY})

# En Ghidra, podemos ver que la funcion que dice que la licencia es valida esta en 0010187d, mientras que la funcion que dice invalid licence queda en 00101890, por lo que no queremos llegar ahi. Como el binario es PIE-enabled, angr por default pone el base address en 0x400000. A esto, necesitamos sumarle el offset donde estan las salidas que queremos. En las direcciones de las funciones, el 0010 es el base address del programa, entonces no hace falta en la suma. No tiene que ver con la funcion.
exit_point = 0x400000 + 0x187d
avoid_point = 0x400000 + 0x1890

sm = p.factory.simulation_manager(state)  # Create simulation manager

sm.explore(find=exit_point, avoid = avoid_point)
if sm.found:
    solution = sm.found[0].solver.eval(argv[1], cast_to=bytes)
    print(solution)